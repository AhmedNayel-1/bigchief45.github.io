<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
  <link href="//gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.52" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>Ruby Benchmarking &amp; Big O Notation &middot; Andrés Álvarez</title>

  
  <link type="text/css" rel="stylesheet" href="http://aalvarez.mecss/print.css" media="print">
  <link type="text/css" rel="stylesheet" href="http://aalvarez.mecss/poole.css">
  <link type="text/css" rel="stylesheet" href="http://aalvarez.mecss/syntax.css">
  <link type="text/css" rel="stylesheet" href="http://aalvarez.mecss/hyde.css">
  <link type="text/css" rel="stylesheet" href="http://aalvarez.mecss/extra.css">
  <link type="text/css" rel="stylesheet" href="http://aalvarez.mecss/overrides.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">


  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Andrés Álvarez" />

  
</head>

  <body class="theme-base-08 ">
  <aside class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://aalvarez.me"><h1>Andrés Álvarez</h1></a>
      <p class="lead">
       Software Engineer &amp; Web Developer 
      </p>
    </div>

    <nav>
      <ul class="sidebar-nav">
        <li><a href="http://aalvarez.me">Home</a> </li>
        <li><a href="/tags/">Tags</a></li>
        <li><a href="/about/"> About Me </a></li><li><a href="/portfolio/"> Portfolio </a></li>
      </ul>
    </nav>

    
    <ul id="social-media" class="list-inline">
      
        <li>
           <a href="mailto:andresalvarez353@gmail.com" target="_blank"><i class="fa fa-envelope fa-2x" title="E-Mail"></i></a>
        </li>
      

      
        <li>
          <a href="https://linkedin.com/in/aalvarez4" target="_blank"><i class="fa fa-linkedin fa-2x" title="LinkedIn"></i></a>
        </li>
      

      
        <li>
          <a href="https://github.com/BigChief45" target="_blank"><i class="fa fa-github fa-2x" title="Github"></i></a>
        </li>
      

      
        <li>
          <a href="https://www.instagram.com/aalvarez300" target="_blank"><i class="fa fa-instagram fa-2x" title="Instagram"></i></a>
        </li>
      

      
        <li>
          <a href="/feed.xml" target="_blank"><i class="fa fa-rss fa-2x" title="RSS"></i></a>
        </li>
      
    </ul>

    <p>&copy; 2018. All rights reserved. </p>
  </div>
</aside>

    <main class="content container">
    <div class="post">
  <h1>Ruby Benchmarking &amp; Big O Notation</h1>
  <time datetime=2016-11-15T00:00:00Z class="post-date">Tue, Nov 15, 2016</time>

  <p>The Ruby <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/benchmark/rdoc/Benchmark.html">Benchmark</a> library helps us to measure how long it takes for a block of code to run. Similar to when you subtract starting time and ending time in other languages such as Java.</p>

<p>I was doing some <a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O Notation</a> reviewing with Ruby the other day and did some common algorithm implementations for each of the most common Big O notations, just for fun.</p>

<h2 id="using-benchmark">Using Benchmark</h2>

<p>To start benchmarking our code, we simply need to require <code>benchmark</code> and use the methods provided by the <code>Benchmark</code> module. For me, the most practical way is to use <code>Benchmark#bm</code> method, where we pass a block of code we want to measure:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#007020">require</span> <span style="background-color:#fff0f0">&#39;benchmark&#39;</span>

<span style="color:#036;font-weight:bold">Benchmark</span><span style="color:#333">.</span>bm <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>x<span style="color:#333">|</span>
  x<span style="color:#333">.</span>report <span style="color:#080;font-weight:bold">do</span>
    <span style="color:#888"># our code here</span>
  <span style="color:#080;font-weight:bold">end</span>

<span style="color:#080;font-weight:bold">end</span></code></pre></div>
<p>Inside the block we are using the <code>report</code> method of the block&rsquo;s variable, which will basically do a separate benchmark for each report.</p>

<p>However, we can improve this even more by adding a label to <code>report</code> and a label width to <code>bm</code>:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#007020">require</span> <span style="background-color:#fff0f0">&#39;benchmark&#39;</span>

<span style="color:#036;font-weight:bold">Benchmark</span><span style="color:#333">.</span>bm(<span style="color:#00d;font-weight:bold">20</span>) <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>x<span style="color:#333">|</span>
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;my_algorithm&#34;</span>) <span style="color:#080;font-weight:bold">do</span>
    <span style="color:#888"># our code here</span>
  <span style="color:#080;font-weight:bold">end</span>
<span style="color:#080;font-weight:bold">end</span></code></pre></div>
<p>Let&rsquo;s see it in action with some common algorithms.</p>

<h2 id="what-is-big-o-notation">What is Big O Notation?</h2>

<p>Big O notation is a special notation that measures how well a computer algorithm scales, as the amount of data involved increases (becomes closer to infinity). It is not necessarily a measurement of <em>speed</em>, but of how well the algorithm <em>scales</em>.</p>

<p>The following are some of the most common Big O notations, with algorithms and benchmarks.</p>

<h3 id="o-1"><em>O(1)</em></h3>

<p><em>O(1)</em> represents <strong>constant</strong> time. This means that the algorithm will execute in the same amount of time <strong>regardless</strong> of the amount of data or input. This is an ideal time complexity, and in algorithms with a time complexity greater than <em>O(1)</em> it can still be achieved by using techniques such as <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a>.</p>

<p>An example of <em>O(1)</em> would be simply adding an element to an array. The size of the array won&rsquo;t matter when simply adding a new element at the end:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#036;font-weight:bold">Benchmark</span><span style="color:#333">.</span>bm(<span style="color:#00d;font-weight:bold">10</span>) <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>x<span style="color:#333">|</span>
  a <span style="color:#333">=</span> <span style="color:#333">[</span><span style="color:#00d;font-weight:bold">1</span>, <span style="color:#00d;font-weight:bold">2</span>, <span style="color:#00d;font-weight:bold">3</span>, <span style="color:#00d;font-weight:bold">4</span>, <span style="color:#00d;font-weight:bold">5</span><span style="color:#333">]</span>
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;add_element&#34;</span>) { a<span style="color:#333">.</span>push(<span style="color:#00d;font-weight:bold">6</span>) }

  a <span style="color:#333">=</span> (<span style="color:#00d;font-weight:bold">1</span><span style="color:#333">..</span><span style="color:#00d;font-weight:bold">9_000_000</span>)<span style="color:#333">.</span>to_a
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;add_element&#34;</span>) { a<span style="color:#333">.</span>push(<span style="color:#00d;font-weight:bold">6</span>) }
<span style="color:#080;font-weight:bold">end</span></code></pre></div>
<p>The benchmark results are:</p>

<pre><code>                 user     system      total        real
add_element  0.000000   0.000000   0.000000 (  0.000003)
add_element  0.000000   0.000000   0.000000 (  0.000012)
</code></pre>

<p>We can clearly see that there is practically no difference between adding to the 5 element array and adding to the 9 million element array.</p>

<h3 id="o-n"><em>O(n)</em></h3>

<p><em>O(n)</em> represents <strong>linear</strong> time. This means that the time to complete the algorithm is proportional to the amount of data. A good example of this is <strong>linear search</strong>, simply because looking for an element in a 9 million size array will take a lot longer than looking in a 10 size element array.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#888"># O(N)</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06b;font-weight:bold">linear_search</span>(array, value)
  array<span style="color:#333">.</span>each { <span style="color:#333">|</span>i<span style="color:#333">|</span> <span style="color:#080;font-weight:bold">return</span> i <span style="color:#080;font-weight:bold">if</span> i <span style="color:#333">==</span> value }
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#036;font-weight:bold">Benchmark</span><span style="color:#333">.</span>bm(<span style="color:#00d;font-weight:bold">50</span>) <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>x<span style="color:#333">|</span>
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;linear_search(1,000)&#34;</span>) { linear_search(<span style="color:#00d;font-weight:bold">1000</span>) }
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;linear_search(10,000,000)&#34;</span>) { linear_search(<span style="color:#00d;font-weight:bold">10_000_000</span>) }
<span style="color:#080;font-weight:bold">end</span></code></pre></div>
<p>The benchmark results are:</p>

<pre><code>                                                         user     system      total        real
linear_search(1,000)                                 0.000000   0.000000   0.000000 (  0.000102)
linear_search(10,000,000)                             0.700000   0.000000   0.700000 (  0.722858)
</code></pre>

<p>Still pretty fast, but the difference is very noticeable.</p>

<h3 id="o-n-2"><em>O(n^2)</em></h3>

<p><em>O(n^2)</em> indicates that the amount to complete will be proportional to the <strong>square</strong> of the amount of data. This usually happens with algorithms that have nested loops. A good example of this notation is the <a href="https://en.wikipedia.org/wiki/Bubble_sort">bubble sort algorithm</a>.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt="Bubble Sort" /></p>

<p>Here is a simple implementation in Ruby, with its corresponding benchmarks:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#888"># O(N^2)</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06b;font-weight:bold">bubble_sort</span>(array)
  n <span style="color:#333">=</span> array<span style="color:#333">.</span>length

  <span style="color:#038;font-weight:bold">loop</span> <span style="color:#080;font-weight:bold">do</span>
    swapped <span style="color:#333">=</span> <span style="color:#038;font-weight:bold">false</span>

    (n<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>)<span style="color:#333">.</span>times <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>i<span style="color:#333">|</span>
      <span style="color:#080;font-weight:bold">if</span> array<span style="color:#333">[</span>i<span style="color:#333">]</span> <span style="color:#333">&gt;</span> array<span style="color:#333">[</span>i<span style="color:#333">+</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#333">]</span>
        array<span style="color:#333">[</span>i<span style="color:#333">]</span>, array<span style="color:#333">[</span>i<span style="color:#333">+</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#333">]</span> <span style="color:#333">=</span> array<span style="color:#333">[</span>i<span style="color:#333">+</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#333">]</span>, array<span style="color:#333">[</span>i<span style="color:#333">]</span>
        swapped <span style="color:#333">=</span> <span style="color:#038;font-weight:bold">true</span>
      <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">end</span>
    <span style="color:#080;font-weight:bold">break</span> <span style="color:#080;font-weight:bold">if</span> <span style="color:#000;font-weight:bold">not</span> swapped
  <span style="color:#080;font-weight:bold">end</span>

  array
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#036;font-weight:bold">Benchmark</span><span style="color:#333">.</span>bm(<span style="color:#00d;font-weight:bold">50</span>) <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>x<span style="color:#333">|</span>
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;bubble_sort([1..10])&#34;</span>) { bubble_sort((<span style="color:#00d;font-weight:bold">1</span><span style="color:#333">..</span><span style="color:#00d;font-weight:bold">10</span>)<span style="color:#333">.</span>to_a<span style="color:#333">.</span>shuffle) }
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;bubble_sort([1..10,000])&#34;</span>) { bubble_sort((<span style="color:#00d;font-weight:bold">1</span><span style="color:#333">..</span><span style="color:#00d;font-weight:bold">10_000</span>)<span style="color:#333">.</span>to_a<span style="color:#333">.</span>shuffle) }
<span style="color:#080;font-weight:bold">end</span></code></pre></div>
<p>The benchmark results are:</p>

<pre><code>                                                         user     system      total        real
bubble_sort([1..10])                                 0.000000   0.000000   0.000000 (  0.000039)
bubble_sort([1..10,000])                            13.990000   0.010000  14.000000 ( 14.028724)
</code></pre>

<p>Now we are starting to see a lot more difference. This is because we initially have to loop through the whole array, and for <strong><em>each</em></strong> element in the iteration, we loop through the whole array <strong><em>again</em></strong>. Hence resulting in: <em>O(n) x O(n) = O(n^2)</em>.</p>

<p>When the amount of input is relatively small, <em>O(n^2)</em> algorithm&rsquo;s bad performance will not be that obvious. But as the input size grows, it will become more evident, and that is why <em>O(n^2)</em> algorithms are generally avoided for big inputs.</p>

<h3 id="o-log-n"><em>O(log n)</em></h3>

<p><em>O(log n)</em> is a much more efficient algorithm. This is because the input used is decreased by around 50% each time through the algorithm. These kind of algorithms are very fast and efficient because increases in the amount of data have little to no effect at some point early on because the amount of data is half each time.</p>

<p>A good example of an <em>O(log n)</em> algorithm is the <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search algorithm</a>:</p>

<p><img src="https://blog.penjee.com/wp-content/uploads/2015/04/binary-and-linear-search-animations.gif" alt="Binary Search vs Linear Search" /></p>

<p>In Ruby, we can implement a binary search in the following way (<em><strong>NOTE:</strong> The array must be initially sorted for the algorithm to work.</em>):</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#888"># O( log N )</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06b;font-weight:bold">binary_search</span>(array, element, low<span style="color:#333">=</span><span style="color:#00d;font-weight:bold">0</span>, high<span style="color:#333">=</span>array<span style="color:#333">.</span>length<span style="color:#333">-</span><span style="color:#00d;font-weight:bold">1</span>)
  <span style="color:#080;font-weight:bold">return</span> <span style="color:#038;font-weight:bold">nil</span> <span style="color:#080;font-weight:bold">if</span> high <span style="color:#333">&lt;</span> low

  mid <span style="color:#333">=</span> ( low <span style="color:#333">+</span> high ) <span style="color:#000;background-color:#fff0ff">/ 2
</span><span style="color:#000;background-color:#fff0ff">
</span><span style="color:#000;background-color:#fff0ff">  if array[mid] &gt; element
</span><span style="color:#000;background-color:#fff0ff">    return binary_search(array, element, low, mid - 1)
</span><span style="color:#000;background-color:#fff0ff">  elsif array[mid] &lt; element
</span><span style="color:#000;background-color:#fff0ff">    return binary_search(array, element, mid + 1, high)
</span><span style="color:#000;background-color:#fff0ff">  else
</span><span style="color:#000;background-color:#fff0ff">    return mid
</span><span style="color:#000;background-color:#fff0ff">  end
</span><span style="color:#000;background-color:#fff0ff">end
</span><span style="color:#000;background-color:#fff0ff">
</span><span style="color:#000;background-color:#fff0ff">Benchmark.bm(50) do |x|
</span><span style="color:#000;background-color:#fff0ff">  x.report(&#34;binary_search([1..10])&#34;) { binary_search((1..10).to_a, 4) }
</span><span style="color:#000;background-color:#fff0ff">  x.report(&#34;binary_search([1..5,000,000])&#34;) { binary_search((1..5_000_000).to_a, 4_999_999) }
</span><span style="color:#000;background-color:#fff0ff">end</span></code></pre></div>
<p>The benchmark results are:</p>

<pre><code>                                                         user     system      total        real
binary_search([1..10])                               0.000000   0.000000   0.000000 (  0.000011)
binary_search([1..5,000,000])                        0.190000   0.000000   0.190000 (  0.192921)
</code></pre>

<p>It is clearly obvious that the performance difference of the algorithm with an array of size 10 compared to that of with an array of size <strong>5,000,000</strong> is almost non-existent, even when using a &ldquo;worst case&rdquo; (in this case, the element before the last one).</p>

<h3 id="o-n-log-n"><em>O(n log n)</em></h3>

<p>In sorting algorithms, a time complexity of <strong>at least</strong> <em>O(n)</em> is unavoidable (at least in theory). This is because we have to look at each element in the array at least once in order to properly sort it. At the same time, an order of <em>O(n^2)</em> is to be avoided.</p>

<p><em>O(n log n)</em> sorting algorithms are more efficient because values are only compared <strong>once</strong>, instead of being compared to each other repeatedly. This means that each comparison will reduce the possible final sorted list in half.</p>

<p>In other words, we can calculate the number of comparisons like this:</p>

<pre><code>number_comparisons = log(n!)
      log(n) + log(n-1) + ... + log(1)
      nlog(n)
      log n + log (n-1) + ... + log (n/2)
      n/2 * log (n/2)
  =&gt;  nlog(n)
</code></pre>

<p>A good example of a <em>O(n log n)</em> algorithm is the <a href="https://en.wikipedia.org/wiki/Quicksort">quick sort algorithm</a>:</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="Quicksort" /></p>

<p>In Ruby, we can implement Quicksort like this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#888"># O( N log N )</span>
<span style="color:#080;font-weight:bold">def</span> <span style="color:#06b;font-weight:bold">quick_sort</span>(array)
  <span style="color:#080;font-weight:bold">return</span> array <span style="color:#080;font-weight:bold">if</span> array<span style="color:#333">.</span>length <span style="color:#333">&lt;=</span> <span style="color:#00d;font-weight:bold">1</span>

  pivot <span style="color:#333">=</span> array<span style="color:#333">[</span><span style="color:#00d;font-weight:bold">0</span><span style="color:#333">]</span>

  less, greatereq <span style="color:#333">=</span> array<span style="color:#333">[</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#333">..-</span><span style="color:#00d;font-weight:bold">1</span><span style="color:#333">].</span>partition { <span style="color:#333">|</span>x<span style="color:#333">|</span> x <span style="color:#333">&lt;</span> pivot }
  quick_sort(less) <span style="color:#333">+</span> <span style="color:#333">[</span>pivot<span style="color:#333">]</span> <span style="color:#333">+</span> quick_sort(greatereq)
<span style="color:#080;font-weight:bold">end</span>

<span style="color:#036;font-weight:bold">Benchmark</span><span style="color:#333">.</span>bm(<span style="color:#00d;font-weight:bold">50</span>) <span style="color:#080;font-weight:bold">do</span> <span style="color:#333">|</span>x<span style="color:#333">|</span>
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;quick_sort([1..20])&#34;</span>) { quick_sort((<span style="color:#00d;font-weight:bold">1</span><span style="color:#333">..</span><span style="color:#00d;font-weight:bold">20</span>)<span style="color:#333">.</span>to_a<span style="color:#333">.</span>shuffle) }
  x<span style="color:#333">.</span>report(<span style="background-color:#fff0f0">&#34;quick_sort([1..400,000])&#34;</span>) { quick_sort((<span style="color:#00d;font-weight:bold">1</span><span style="color:#333">..</span><span style="color:#00d;font-weight:bold">400_000</span>)<span style="color:#333">.</span>to_a<span style="color:#333">.</span>shuffle) }
<span style="color:#080;font-weight:bold">end</span></code></pre></div>
<p>Notice how multiple assignment and the <a href="https://ruby-doc.org/core-2.3.1/Enumerable.html#method-i-partition">partition</a> method from <code>Enumerable</code> is used. This method will return two arrays: the first array will contain elements for which the block evaluates to <code>true</code>, and the second one containing the rest.</p>

<p>The benchmark yields the following results:</p>

<pre><code>                                                         user     system      total        real
quick_sort([1..20])                                  0.000000   0.000000   0.000000 (  0.000048)
quick_sort([1..400,000])                             1.400000   0.020000   1.420000 (  1.430095)
</code></pre>

<h2 id="closing-thoughts">Closing Thoughts</h2>

<p>Even though those are the most common Big O time complexity notations, there are even more complicated complexities (lol?) out there.</p>

<p>Moreover, there are also other asymptotic notations that use different symbols to describe different kinds of bounds. I hope to cover these sometime in the future.</p>
</div>


<div style="margin: 20px 0px;">
  
    <a href="http://aalvarez.me/tags/ruby" class="label label-default">ruby</a></li>
  
    <a href="http://aalvarez.me/tags/algorithms" class="label label-default">algorithms</a></li>
  
    <a href="http://aalvarez.me/tags/programming" class="label label-default">programming</a></li>
  
    <a href="http://aalvarez.me/tags/benchmarking" class="label label-default">benchmarking</a></li>
  
    <a href="http://aalvarez.me/tags/mathematics" class="label label-default">mathematics</a></li>
  
    <a href="http://aalvarez.me/tags/computerscience" class="label label-default">computerscience</a></li>
  
</div>


<h2>Comments</h2>
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "aalvarez-blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </main>

    
  </body>
</html>
